const { Connection } = require('@solana/web3.js');
const axios = require('axios');
const { ipcMain } = require('electron');
require('dotenv').config();

const { SOL_AMOUNT = 10, WS_TOKEN, TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID } = process.env;

const sendTelegramMessage = async (message, log) => {
  try {
    const botToken = process.env.TELEGRAM_BOT_TOKEN;
    const chatId = process.env.TELEGRAM_CHAT_ID;

    const url = `https://api.telegram.org/bot${botToken}/sendMessage`;

    const response = await axios.post(url, {
      chat_id: chatId,
      text: message
    });

    console.log('–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –Ω–∞–¥—ñ—Å–ª–∞–Ω–æ –≤ Telegram:', response.data);
    log('–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –Ω–∞–¥—ñ—Å–ª–∞–Ω–æ –≤ Telegram: ' + message);
  } catch (error) {
    console.error('–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –≤—ñ–¥–ø—Ä–∞–≤—Ü—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –≤ Telegram:', error.message);
    log('–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –≤—ñ–¥–ø—Ä–∞–≤—Ü—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è: ' + error.message);
  }
};

const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));

const getBlockWithRetry = async (connection, slot, log, maxRetries = 5, delay = 3000) => {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      console.log(`–°–ø—Ä–æ–±–∞ ${attempt} –æ—Ç—Ä–∏–º–∞—Ç–∏ –±–ª–æ–∫ –¥–ª—è —Å–ª–æ—Ç–∞: ${slot}`);
      log(`–°–ø—Ä–æ–±–∞ ${attempt} –æ—Ç—Ä–∏–º–∞—Ç–∏ –±–ª–æ–∫ –¥–ª—è —Å–ª–æ—Ç–∞: ${slot}`);
      const block = await connection.getBlock(slot, {
        commitment: 'finalized',
        transactionDetails: 'full', 
        rewards: true, 
        maxSupportedTransactionVersion: 0, 
      });

      if (block) {
        console.log(`–ë–ª–æ–∫ –¥–ª—è —Å–ª–æ—Ç–∞ ${slot} —É—Å–ø—ñ—à–Ω–æ –æ—Ç—Ä–∏–º–∞–Ω–æ.`);
        log(`–ë–ª–æ–∫ –¥–ª—è —Å–ª–æ—Ç–∞ ${slot} —É—Å–ø—ñ—à–Ω–æ –æ—Ç—Ä–∏–º–∞–Ω–æ.`);
        return block;
      }
    } catch (error) {
      console.error(`–ü–æ–º–∏–ª–∫–∞ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –±–ª–æ–∫—É –¥–ª—è —Å–ª–æ—Ç–∞ ${slot} (—Å–ø—Ä–æ–±–∞ ${attempt}/${maxRetries}):`, error.message);
      log(`–ü–æ–º–∏–ª–∫–∞ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –±–ª–æ–∫—É –¥–ª—è —Å–ª–æ—Ç–∞ ${slot} (—Å–ø—Ä–æ–±–∞ ${attempt}/${maxRetries}): ${error.message}`);
    }
    
    console.log(`–û—á—ñ–∫—É–≤–∞–Ω–Ω—è ${delay} –º—Å –ø–µ—Ä–µ–¥ –ø–æ–≤—Ç–æ—Ä–æ–º...`);
    await wait(delay);
  }

  throw new Error(`–ë–ª–æ–∫ –¥–ª—è —Å–ª–æ—Ç–∞ ${slot} –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ –ø—ñ—Å–ª—è ${maxRetries} —Å–ø—Ä–æ–±.`);
};

const main = async (log, stopCallback) => {
  try {
    const httpUrl = `https://rpc-mainnet.solanatracker.io/?api_key=${process.env.WS_TOKEN}`;
    const connectionHttp = new Connection(httpUrl, 'finalized');

    log('üì° –ü—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –¥–æ Solana —á–µ—Ä–µ–∑ HTTP RPC...');

    let lastSlot = await connectionHttp.getSlot('finalized');
    log(`üì¶ –ü–æ—á–∞—Ç–∫–æ–≤–∏–π —Å–ª–æ—Ç: ${lastSlot}`);

    while (true) {
      if (stopCallback()) {
        log('üõë –û—Å–Ω–æ–≤–Ω–∏–π –ø—Ä–æ—Ü–µ—Å –∑—É–ø–∏–Ω–µ–Ω–æ.');
        break;
      }

      log(`üì¶ –û–±—Ä–æ–±–ª—è—î—Ç—å—Å—è —Å–ª–æ—Ç: ${lastSlot}`);

      try {
        const block = await getBlockWithRetry(connectionHttp, lastSlot, log);

        log(`üîç –ö—ñ–ª—å–∫—ñ—Å—Ç—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ–π —É –±–ª–æ—Ü—ñ: ${block.transactions.length}`);

        const systemProgramId = '11111111111111111111111111111111';
        const minAmountLamports = BigInt(process.env.SOL_AMOUNT * 1e9); 

        const highValueTransactions = await Promise.all(
          block.transactions.map(async (tx) => {
            if (!tx.transaction || !tx.transaction.message || !tx.transaction.message.instructions) {
              return null;
            }

            const accountKeys = tx.transaction.message.accountKeys;
            const instructions = tx.transaction.message.instructions;

            for (const instruction of instructions) {
              if (!accountKeys[instruction.programIdIndex]) {
                log(`‚ö†Ô∏è ProgramIdIndex ${instruction.programIdIndex} –≤–∏—Ö–æ–¥–∏—Ç—å –∑–∞ –º–µ–∂—ñ accountKeys —É —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—ó: ${tx.transaction.signatures[0]}`);
                continue;
              }

              const programId = accountKeys[instruction.programIdIndex].toString();
              const dataBuffer = Buffer.from(instruction.data, 'base64');

              if (programId === systemProgramId && dataBuffer[0] === 2) {
                if (dataBuffer.length >= 9) {
                  const lamports = dataBuffer.readBigUInt64LE(1);
                  const solAmount = Number(lamports) / 1e9;

                  if (lamports >= minAmountLamports) {
                    const receiverIndex = instruction.accounts[1]; 
                    const receiverAddress = accountKeys[receiverIndex].toString();
                    log(`üí∏ –û—Ç—Ä–∏–º—É–≤–∞—á: ${receiverAddress}, –õ–∞–º–ø–æ—Ä—Ç–∏: ${lamports} (${solAmount} SOL)`);

                    // –û—Ç—Ä–∏–º–∞—Ç–∏ –±–∞–ª–∞–Ω—Å –ø–µ—Ä–µ–¥ —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—î—é
                    const preBalance = await connectionHttp.getBalance(receiverAddress, 'processed');
                    log(`üí∞ –ë–∞–ª–∞–Ω—Å –¥–æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—ó: ${preBalance / 1e9} SOL –¥–ª—è –æ—Ç—Ä–∏–º—É–≤–∞—á–∞: ${receiverAddress}`);

                    if (preBalance === 0) {
                      const message = `üí∞ –ù–æ–≤–∏–π –≥–∞–º–∞–Ω–µ—Ü—å –≤–∏—è–≤–ª–µ–Ω–æ: ${receiverAddress} –æ—Ç—Ä–∏–º–∞–≤ ${solAmount} SOL`;
                      log(message);
                      await sendTelegramMessage(message);
                    }

                    return {
                      signature: tx.transaction.signatures[0],
                      receiver: receiverAddress,
                      solAmount
                    };
                  }
                } else {
                  log(`‚ö†Ô∏è –ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ –±–∞–π—Ç—ñ–≤ —É dataBuffer –¥–ª—è –∑—á–∏—Ç—É–≤–∞–Ω–Ω—è –ª–∞–º–ø–æ—Ä—Ç—ñ–≤. –¢—Ä–∞–Ω–∑–∞–∫—Ü—ñ—è: ${tx.transaction.signatures[0]}`);
                }
              }
            }
            return null;
          })
        );

        const validTransactions = highValueTransactions.filter(tx => tx !== null);

        log(`üìã –ö—ñ–ª—å–∫—ñ—Å—Ç—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ–π —ñ–∑ —Ç—Ä–∞–Ω—Å—Ñ–µ—Ä–æ–º ${process.env.SOL_AMOUNT}+ SOL: ${validTransactions.length}`);

        validTransactions.forEach((tx, index) => {
          log(`üîó –¢—Ä–∞–Ω–∑–∞–∫—Ü—ñ—è –∑ —Ç—Ä–∞–Ω—Å—Ñ–µ—Ä–æ–º ${process.env.SOL_AMOUNT}+ SOL ${index + 1}: –ü—ñ–¥–ø–∏—Å: ${tx.signature}, –û—Ç—Ä–∏–º—É–≤–∞—á: ${tx.receiver}, –°—É–º–∞: ${tx.solAmount} SOL`);
        });

      } catch (error) {
        log(`‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ–±—Ä–æ–±—Ü—ñ —Å–ª–æ—Ç–∞ ${lastSlot}: ${error.message}`);
      }

      lastSlot += 1; // –ó–±—ñ–ª—å—à—É—î–º–æ —Å–ª–æ—Ç –≤—Ä—É—á–Ω—É
      log(`üì¶ –°–ª–æ—Ç –∑–±—ñ–ª—å—à–µ–Ω–æ –¥–æ: ${lastSlot}`);
    }
  } catch (error) {
    log(`‚ùå –ü–æ–º–∏–ª–∫–∞: ${error.message}`);
  }
};

module.exports = { main };
